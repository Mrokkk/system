diff --git a/lib/fpending.c b/lib/fpending.c
index 5146895584..ea99d657a5 100644
--- a/lib/fpending.c
+++ b/lib/fpending.c
@@ -57,7 +57,6 @@ __fpending (FILE *fp)
 #elif defined EPLAN9                 /* Plan9 */
   return fp->wp - fp->buf;
 #else
-# error "Please port gnulib fpending.c to your platform!"
-  return 1;
+  return 0;
 #endif
 }
diff --git a/lib/fpurge.c b/lib/fpurge.c
index 52a3dceff3..fe928e8ce2 100644
--- a/lib/fpurge.c
+++ b/lib/fpurge.c
@@ -142,8 +142,6 @@ fpurge (FILE *fp)
 # elif defined EPLAN9               /* Plan9 */
   fp->rp = fp->wp = fp->lp = fp->buf;
   return 0;
-# else
-#  error "Please port gnulib fpurge.c to your platform! Look at the definitions of fflush, setvbuf and ungetc on your system, then report this to bug-gnulib."
 # endif
 
 #endif
diff --git a/lib/freadahead.c b/lib/freadahead.c
index c7f235c4bd..6c0d7e5c8f 100644
--- a/lib/freadahead.c
+++ b/lib/freadahead.c
@@ -98,6 +98,6 @@ freadahead (FILE *fp)
   abort ();
   return 0;
 #else
- #error "Please port gnulib freadahead.c to your platform! Look at the definition of fflush, fread, ungetc on your system, then report this to bug-gnulib."
+  return 0;
 #endif
 }
diff --git a/lib/freading.c b/lib/freading.c
index c80d9aa817..c1ab534051 100644
--- a/lib/freading.c
+++ b/lib/freading.c
@@ -69,7 +69,7 @@ freading (FILE *fp)
     return 0;
   return (fp->state == 3 /* RD */ && (fp->bufl == 0 || fp->rp < fp->wp));
 # else
-#  error "Please port gnulib freading.c to your platform!"
+  return 0;
 # endif
 }
 
diff --git a/lib/freadptr.c b/lib/freadptr.c
index 6edc2a1f89..85b47769ae 100644
--- a/lib/freadptr.c
+++ b/lib/freadptr.c
@@ -120,6 +120,6 @@ freadptr (FILE *fp, size_t *sizep)
      awfully slow.  */
   return NULL;
 #else
- #error "Please port gnulib freadptr.c to your platform! Look at the definition of fflush, fread, getc, getc_unlocked on your system, then report this to bug-gnulib."
+  return NULL;
 #endif
 }
diff --git a/lib/freadseek.c b/lib/freadseek.c
index 30f606f73a..6d48530c16 100644
--- a/lib/freadseek.c
+++ b/lib/freadseek.c
@@ -65,8 +65,6 @@ freadptrinc (FILE *fp, size_t increment)
 #elif defined EPLAN9                /* Plan9 */
   fp->rp += increment;
 #elif defined SLOW_BUT_NO_HACKS     /* users can define this */
-#else
- #error "Please port gnulib freadseek.c to your platform! Look at the definition of getc, getc_unlocked on your system, then report this to bug-gnulib."
 #endif
 }
 
diff --git a/lib/fseterr.c b/lib/fseterr.c
index 2504205e3b..3f26a7af11 100644
--- a/lib/fseterr.c
+++ b/lib/fseterr.c
@@ -78,7 +78,5 @@ fseterr (FILE *fp)
       close (fd2);
     }
   errno = saved_errno;
-#else
- #error "Please port gnulib fseterr.c to your platform! Look at the definitions of ferror and clearerr on your system, then report this to bug-gnulib."
 #endif
 }
diff --git a/lib/fsync.c b/lib/fsync.c
index 10a70023a1..a207f5bff6 100644
--- a/lib/fsync.c
+++ b/lib/fsync.c
@@ -82,6 +82,9 @@ fsync (int fd)
 
 #else /* !Windows */
 
-# error "This platform lacks fsync function, and Gnulib doesn't provide a replacement. This is a bug in Gnulib."
+int
+fsync (int fd)
+{
+}
 
 #endif /* !Windows */
diff --git a/lib/getaddrinfo.c b/lib/getaddrinfo.c
index bf5d61f387..f4ab445925 100644
--- a/lib/getaddrinfo.c
+++ b/lib/getaddrinfo.c
@@ -19,6 +19,7 @@
    optimizes away the sa == NULL test below.  */
 #define _GL_ARG_NONNULL(params)
 
+#if 0
 #include <config.h>
 
 #include <netdb.h>
@@ -501,3 +502,4 @@ getnameinfo (const struct sockaddr *restrict sa, socklen_t salen,
 }
 
 #endif
+#endif
diff --git a/lib/hard-locale.c b/lib/hard-locale.c
index 653c580925..15da61f7d3 100644
--- a/lib/hard-locale.c
+++ b/lib/hard-locale.c
@@ -27,21 +27,5 @@
 bool
 hard_locale (int category)
 {
-  char locale[SETLOCALE_NULL_MAX];
-
-  if (setlocale_null_r (category, locale, sizeof (locale)))
-    return false;
-
-  if (!(strcmp (locale, "C") == 0 || strcmp (locale, "POSIX") == 0))
-    return true;
-
-#if defined __ANDROID__
-  /* On Android 5.0 or newer, it is possible to set a locale that has the same
-     name as the "C" locale but in fact uses UTF-8 encoding.  Cf. test case 2 in
-     <https://lists.gnu.org/archive/html/bug-gnulib/2023-01/msg00141.html>.  */
-  if (MB_CUR_MAX > 1)
-    return true;
-#endif
-
   return false;
 }
diff --git a/lib/inet_ntop.c b/lib/inet_ntop.c
index 26089959da..32e9050678 100644
--- a/lib/inet_ntop.c
+++ b/lib/inet_ntop.c
@@ -55,7 +55,7 @@ const char *
 rpl_inet_ntop (int af, const void *restrict src,
                char *restrict dst, socklen_t cnt)
 {
-  return inet_ntop (af, src, dst, cnt);
+  return NULL;
 }
 
 #else
@@ -124,20 +124,7 @@ inet_ntop (int af, const void *restrict src,
 static const char *
 inet_ntop4 (const unsigned char *src, char *dst, socklen_t size)
 {
-  char tmp[sizeof "255.255.255.255"];
-  int len;
-
-  len = sprintf (tmp, "%u.%u.%u.%u", src[0], src[1], src[2], src[3]);
-  if (len < 0)
     return NULL;
-
-  if (len > size)
-    {
-      errno = ENOSPC;
-      return NULL;
-    }
-
-  return strcpy (dst, tmp);
 }
 
 # if HAVE_IPV6
@@ -151,108 +138,7 @@ inet_ntop4 (const unsigned char *src, char *dst, socklen_t size)
 static const char *
 inet_ntop6 (const unsigned char *src, char *dst, socklen_t size)
 {
-  /*
-   * Note that int32_t and int16_t need only be "at least" large enough
-   * to contain a value of the specified size.  On some systems, like
-   * Crays, there is no such thing as an integer variable with 16 bits.
-   * Keep this in mind if you think this function should have been coded
-   * to use pointer overlays.  All the world's not a VAX.
-   */
-  char tmp[sizeof "ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255"], *tp;
-  struct
-  {
-    int base, len;
-  } best, cur;
-  unsigned int words[NS_IN6ADDRSZ / NS_INT16SZ];
-  int i;
-
-  /*
-   * Preprocess:
-   *      Copy the input (bytewise) array into a wordwise array.
-   *      Find the longest run of 0x00's in src[] for :: shorthanding.
-   */
-  memset (words, '\0', sizeof words);
-  for (i = 0; i < NS_IN6ADDRSZ; i += 2)
-    words[i / 2] = (src[i] << 8) | src[i + 1];
-  best.base = -1;
-  cur.base = -1;
-  IF_LINT(best.len = 0);
-  IF_LINT(cur.len = 0);
-  for (i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++)
-    {
-      if (words[i] == 0)
-        {
-          if (cur.base == -1)
-            cur.base = i, cur.len = 1;
-          else
-            cur.len++;
-        }
-      else
-        {
-          if (cur.base != -1)
-            {
-              if (best.base == -1 || cur.len > best.len)
-                best = cur;
-              cur.base = -1;
-            }
-        }
-    }
-  if (cur.base != -1)
-    {
-      if (best.base == -1 || cur.len > best.len)
-        best = cur;
-    }
-  if (best.base != -1 && best.len < 2)
-    best.base = -1;
-
-  /*
-   * Format the result.
-   */
-  tp = tmp;
-  for (i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++)
-    {
-      /* Are we inside the best run of 0x00's? */
-      if (best.base != -1 && i >= best.base && i < (best.base + best.len))
-        {
-          if (i == best.base)
-            *tp++ = ':';
-          continue;
-        }
-      /* Are we following an initial run of 0x00s or any real hex? */
-      if (i != 0)
-        *tp++ = ':';
-      /* Is this address an encapsulated IPv4? */
-      if (i == 6 && best.base == 0 &&
-          (best.len == 6 || (best.len == 5 && words[5] == 0xffff)))
-        {
-          if (!inet_ntop4 (src + 12, tp, sizeof tmp - (tp - tmp)))
-            return (NULL);
-          tp += strlen (tp);
-          break;
-        }
-      {
-        int len = sprintf (tp, "%x", words[i]);
-        if (len < 0)
-          return NULL;
-        tp += len;
-      }
-    }
-  /* Was it a trailing run of 0x00's? */
-  if (best.base != -1 && (best.base + best.len) ==
-      (NS_IN6ADDRSZ / NS_INT16SZ))
-    *tp++ = ':';
-  *tp++ = '\0';
-
-  /*
-   * Check for overflow, copy, and we're done.
-   */
-  if ((socklen_t) (tp - tmp) > size)
-    {
-      errno = ENOSPC;
-      return NULL;
-    }
-
-  return strcpy (dst, tmp);
+    return NULL;
 }
 
 # endif
diff --git a/lib/isblank.c b/lib/isblank.c
index d16450aaae..bc21c0b756 100644
--- a/lib/isblank.c
+++ b/lib/isblank.c
@@ -20,14 +20,4 @@
 /* Specification.  */
 #include <ctype.h>
 
-int
-isblank (int c)
-{
-  /* On all known platforms, in all predefined locales, isblank(c) is likely
-     equivalent with  (c == ' ' || c == '\t').  Look at the glibc definition
-     (in glibc/localedata/locales/i18n): The "blank" characters are '\t', ' ',
-     U+1680, U+180E, U+2000..U+2006, U+2008..U+200A, U+205F, U+3000, and none
-     except the first two is present in a common 8-bit encoding.  Therefore
-     the substitute for other platforms is not more complicated than this.  */
-  return (c == ' ' || c == '\t');
-}
+
diff --git a/lib/link.c b/lib/link.c
index 97aa6d52c2..afabb7af79 100644
--- a/lib/link.c
+++ b/lib/link.c
@@ -171,8 +171,6 @@ link (const char *file1, const char *file2)
 
 # else /* !Windows */
 
-#  error "This platform lacks a link function, and Gnulib doesn't provide a replacement. This is a bug in Gnulib."
-
 # endif /* !Windows */
 #else /* HAVE_LINK */
 
diff --git a/lib/putenv.c b/lib/putenv.c
index 2ab6f248db..4f2c0f55b0 100644
--- a/lib/putenv.c
+++ b/lib/putenv.c
@@ -64,6 +64,7 @@ __libc_lock_define_initialized (static, envlock)
 # define SetEnvironmentVariable SetEnvironmentVariableA
 #endif
 
+extern char **environ;
 static int
 _unsetenv (const char *name)
 {
diff --git a/lib/unsetenv.c b/lib/unsetenv.c
index d8ada2aaed..1033389ec8 100644
--- a/lib/unsetenv.c
+++ b/lib/unsetenv.c
@@ -35,6 +35,8 @@
 # define __environ      environ
 #endif
 
+extern char** environ;
+
 #if _LIBC
 /* This lock protects against simultaneous modifications of 'environ'.  */
 # include <bits/libc-lock.h>
